package com.pblabs.rendering2D.fonts
{
    import flash.display.BitmapData;
    import flash.geom.ColorTransform;
    import flash.geom.Point;
    import flash.geom.Rectangle;
    
    /**
     * Represents a bitmapped font which can be drawn to a BitmapData.
     * 
     * Uses BMFont data as generated by BMFont (http://www.angelcode.com/products/bmfont/, win32) or
     * Hiero (http://slick.cokeandcode.com/demos/hiero.jnlp, cross platform).
     * 
     * Currently does not support:
     *      - Kerning.
     *      - Channel packing (currently blits all channels).
     *      - Line breaks/text alignment.
     *      - Unicode outside of the Basic Multilingual Plane. 
     */
    public class BMFont
    {
		public var fontScale : Number = 1;
        public var glyphMap:Array = new Array();
        public var sheets:Array = new Array();
		public var fontName : String;
		
		private var _colorTransform : ColorTransform = new ColorTransform();
		
        /**
         * Draw a string to a BitmapData.
         *  
         * @param target BitmapData to draw to.
         * @param startX X pixel position to start drawing at.
         * @param startY Y pixel position to start drawing at.
         * @param text String to draw.
         * 
         */
        public function drawString(target:BitmapData, startX:int, startY:int, text:String, color : uint = -1):void
        {
            var curX:int = startX;
            var curY:int = startY;
            
            // Walk the string.
            for(var curCharIdx:int = 0; curCharIdx < text.length; curCharIdx++)
            {
                // Identify the glyph.
                var curChar:int = text.charCodeAt(curCharIdx);
                var curGlyph:BMGlyph = glyphMap[curChar];
                if(!curGlyph || !sheets[curGlyph.page]) 
                    continue;
                
                // Draw the glyph.
                target.copyPixels(sheets[curGlyph.page], 
                    new Rectangle(curGlyph.x, curGlyph.y, curGlyph.width, curGlyph.height),
                    new Point(curX + curGlyph.xoffset, curY + curGlyph.yoffset),
                    null, null, true);
                
                // Update cursor position
                curX += curGlyph.xadvance;
            }
			if(color != -1){
				
				var colorMultiplier:Number = 0.00392;
				_colorTransform.redOffset = 0;
				_colorTransform.greenOffset = 0;
				_colorTransform.blueOffset = 0;
				_colorTransform.redMultiplier = (color >> 16) * colorMultiplier;
				_colorTransform.greenMultiplier = (color >> 8 & 0xff) * colorMultiplier;
				_colorTransform.blueMultiplier = (color & 0xff) * colorMultiplier;
				
				target.colorTransform(target.rect, _colorTransform);
			}
        }
        
		public function getAvailableChars():Array
		{
			var list : Array = [];
			for each(var glyph : BMGlyph in glyphMap)
			{
				var str : String = String.fromCharCode(glyph.id);
				if(str)
					list.push( str );
			}
			return list;
		}
		
		public function getStringBounds(text:String, resultBounds : Rectangle = null):Rectangle
		{
			var bounds : Rectangle;
			if(resultBounds)
				bounds = resultBounds;
			else
				bounds = new Rectangle();
			
			var curW:int = 0;
			var curH:int = 0;
			// Walk the string.
			for(var curCharIdx:int = 0; curCharIdx < text.length; curCharIdx++)
			{
				// Identify the glyph.
				var curChar:int = text.charCodeAt(curCharIdx);
				var curGlyph:BMGlyph = glyphMap[curChar];
				if(!curGlyph || !sheets[curGlyph.page]) 
					continue;
				
				// Draw the glyph.
				var increaseHeightBy : Number = (curGlyph.height + curGlyph.yoffset) > curH ? ((curGlyph.height + curGlyph.yoffset) - curH ) : 0;
				curW += curGlyph.xoffset;
				curW += curGlyph.width;
				curH += increaseHeightBy;
			}
			bounds.setTo(0,0, curW, curH);
			return bounds;
		}
        /**
         * Add a bitmap sheet.
         */
        public function addSheet(id:int, data:BitmapData):void
        {
            if(sheets[id] != null)
                throw new Error("Overwriting sheet!");
            sheets[id] = data;            
        }
		
		/**
		 * Parse a BMFont xml font description / coordinate data.
		 */
		public function parseFontXML(fontXml : XML):void
		{
			for each (var charElement:XML in fontXml.chars.char)
			{
				var id:int = parseInt(charElement.attribute("id"));
				fontName = fontXml.info.attribute("face");
				var glyph:BMGlyph = new BMGlyph();
				glyph.id = id;
				glyph.x = parseFloat(charElement.attribute("x")) / fontScale;
				glyph.y = parseFloat(charElement.attribute("y")) / fontScale;
				glyph.width = parseFloat(charElement.attribute("width")) / fontScale;
				glyph.height = parseFloat(charElement.attribute("height")) / fontScale;
				glyph.xoffset = parseFloat(charElement.attribute("xoffset")) / fontScale;
				glyph.yoffset = parseFloat(charElement.attribute("yoffset")) / fontScale;
				glyph.xadvance = parseFloat(charElement.attribute("xadvance")) / fontScale;
				glyph.chnl = parseFloat(charElement.attribute("chnl"));
				glyph.page = parseInt(charElement.attribute("page"));
				
				glyphMap[id] = glyph;
			}
		}
		
		/**
		 * Color Helper method from the ColorUtil class used to extract the Red channel from a color hex value
		 * #http://www.purplesquirrels.com.au/blogstuff/colouruint/ColourUtil.as
		 */
		private function extractRedFromHEX(c:uint):uint
		{
			return (( c >> 16 ) & 0xFF);
		}
		
		/**
		 * Color Helper method from the ColorUtil class used to extract the Green channel from a color hex value
		 * #http://www.purplesquirrels.com.au/blogstuff/colouruint/ColourUtil.as
		 */
		private function extractGreenFromHEX(c:uint):uint
		{
			return ( (c >> 8) & 0xFF );
		}
		
		/**
		 * Color Helper method from the ColorUtil class used to extract the Blue channel from a color hex value
		 * #http://www.purplesquirrels.com.au/blogstuff/colouruint/ColourUtil.as
		 */
		private function extractBlueFromHEX(c:uint):uint
		{
			return ( c & 0xFF );
		}		
    }
}